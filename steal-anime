-- Made by Zero (OxyCoder)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local localPlayer = Players.LocalPlayer

local guiEnabled = true
local connections = {}

-- Load Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Steal Anime OP",
    LoadingTitle = "Loading Steal Tool",
    LoadingSubtitle = "by Zero (OxyCoder)",
    ConfigurationSaving = {
        Enabled = false, -- No need for saving in this script
    }
})

-- Apply a dark theme to match your original UI
Rayfield:SetTheme("Dark") -- Assuming Rayfield supports this; adjust if needed

-- Create the main tab
local MainTab = Window:CreateTab("Main")

-- Dropdown for Bases
local BasesDropdown = MainTab:CreateDropdown({
    Name = "Select Base",
    Options = {},
    CurrentOption = "Select Base",
    Callback = function(Option)
        -- Find the selected base from your list
        local bases = getAllPlayerBases()
        for _, baseInfo in ipairs(bases) do
            if baseInfo.PlayerName .. "'s Base" == Option then
                selectedBase = baseInfo.Base
                updateCharactersList() -- Refresh characters
                CharsDropdown:Refresh({}, true) -- Clear Rayfield dropdown
                local characters = getCharactersFromBase(selectedBase)
                local charOptions = {}
                for _, charInfo in ipairs(characters) do
                    table.insert(charOptions, charInfo.Name .. " (" .. charInfo.Folder .. ")")
                end
                CharsDropdown:Refresh(charOptions, true)
                break
            end
        end
    end
})

-- Dropdown for Characters
local CharsDropdown = MainTab:CreateDropdown({
    Name = "Select Character",
    Options = {},
    CurrentOption = "Select Character",
    Callback = function(Option)
        if not selectedBase then return end
        local characters = getCharactersFromBase(selectedBase)
        for _, charInfo in ipairs(characters) do
            if charInfo.Name .. " (" .. charInfo.Folder .. ")" == Option then
                selectedCharacter = charInfo.Character
                break
            end
        end
    end
})

-- Steal Button
local ActionButton = MainTab:CreateButton({
    Name = "Steal",
    Callback = function()
        -- Your original action logic (unchanged)
        if selectedBase and selectedCharacter then
            print("Base:", selectedBase.Name)
            print("Character:", selectedCharacter.Name)
            
            local localChar = localPlayer.Character
            if not localChar then
                localChar = localPlayer.CharacterAdded:Wait()
            end
            local localHum = localChar:WaitForChild("Humanoid")
            local localHRP = localChar:WaitForChild("HumanoidRootPart")
            
            local targetHRP = selectedCharacter:FindFirstChild("HumanoidRootPart")
            
            if not targetHRP then
                return
            end
            
            local function enableNoclip()
                local noclipConnection
                noclipConnection = RunService.Stepped:Connect(function()
                    if localChar and localHum then
                        for _, part in pairs(localChar:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                    else
                        noclipConnection:Disconnect()
                    end
                end)
                return noclipConnection
            end
            
            local function disableMovement()
                localHum.PlatformStand = true
            end
            
            local function enableFlying()
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
                bodyGyro.P = 10000
                bodyGyro.D = 500
                bodyGyro.CFrame = localHRP.CFrame
                bodyGyro.Parent = localHRP
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.MaxForce = Vector3.new(400000, 400000, 400000)
                bodyVelocity.Parent = localHRP
                
    
                local flyConnection
                flyConnection = RunService.Heartbeat:Connect(function()
                    if localChar and localHRP then
                        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                        
                        local lookAtTarget = CFrame.lookAt(localHRP.Position, targetHRP.Position)
                        local rotatedCFrame = lookAtTarget * CFrame.Angles(math.rad(-90), 0, 0)
                        bodyGyro.CFrame = rotatedCFrame
                    else
                        flyConnection:Disconnect()
                    end
                end)
                
                return bodyGyro, bodyVelocity, flyConnection
            end
            
    
            local function disableAll(bodyGyro, bodyVelocity, flyConnection, noclipConnection)
                if bodyGyro then
                    bodyGyro:Destroy()
                end
                if bodyVelocity then
                    bodyVelocity:Destroy()
                end
                if flyConnection then
                    flyConnection:Disconnect()
                end
                if noclipConnection then
                    noclipConnection:Disconnect()
                end
                if localHum then
                    localHum.PlatformStand = false
                end
    
                if localChar then
                    for _, part in pairs(localChar:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end
            end
    
            local function findLocalBase()
                for baseName, base in pairs(workspace.Bases:GetChildren()) do
                    local sign = base:FindFirstChild("Sign")
                    if sign then
                        local signPart = sign:FindFirstChild("SignPart")
                        if signPart then
                            local surfaceGui = signPart:FindFirstChild("SurfaceGui")
                            if surfaceGui then
                                local textLabel = surfaceGui:FindFirstChild("TextLabel")
                                if textLabel and textLabel.Text then
                                    if string.find(textLabel.Text, localPlayer.Name .. "'s Base") then
                                        return base
                                    end
                                end
                            end
                        end
                    end
                end
                return nil
            end
            
            local noclipConnection = enableNoclip()
            disableMovement()
            
            local backOffset = targetHRP.CFrame.lookVector * -6
            localHRP.CFrame = targetHRP.CFrame + backOffset + Vector3.new(0, 3, 0)
            
            local bodyGyro, bodyVelocity, flyConnection = enableFlying()
            
            local maxWaitTime = 6 
            local startTime = tick()
            
            while tick() - startTime < maxWaitTime do
               
                if selectedCharacter:GetAttribute("Stolen") == true then
                    break
                end
                wait(0.1)
            end
            
            local localBase = findLocalBase()
            if localBase and localBase:FindFirstChild("StealCollect2") then
                local stealCollect = localBase.StealCollect2
                if stealCollect:IsA("Part") then
                    localHRP.CFrame = stealCollect.CFrame + Vector3.new(0, 3, 0)
                end
            end
            
            disableAll(bodyGyro, bodyVelocity, flyConnection, noclipConnection)
            
        else
            print("Select an Base and Char")
        end
    end
})

-- Your original functions (unchanged)
local function getAllPlayerBases()
    local bases = {}
    
    if not workspace:FindFirstChild("Bases") then
        return bases
    end
    
    for baseName, base in pairs(workspace.Bases:GetChildren()) do
        local sign = base:FindFirstChild("Sign")
        if sign then
            local signPart = sign:FindFirstChild("SignPart")
            if signPart then
                local surfaceGui = signPart:FindFirstChild("SurfaceGui")
                if surfaceGui then
                    local textLabel = surfaceGui:FindFirstChild("TextLabel")
                    if textLabel and textLabel.Text then
                        local playerName = string.match(textLabel.Text, "(.+)'s Base")
                        if playerName then
                            table.insert(bases, {
                                Base = base,
                                PlayerName = playerName,
                                BaseName = baseName
                            })
                        end
                    end
                end
            end
        end
    end
    
    return bases
end

local function getCharactersFromBase(base)
    local characters = {}
    
    if not base then return characters end
    
    local characterFolders = {"Characters", "RainbowCharacters", "CosmicCharacters"}
    
    for _, folderName in ipairs(characterFolders) do
        local folder = base:FindFirstChild(folderName)
        if folder then
            for _, char in pairs(folder:GetChildren()) do
                if char:IsA("Model") then
                    table.insert(characters, {
                        Character = char,
                        Name = char.Name,
                        Folder = folderName
                    })
                end
            end
        end
    end
    
    return characters
end

local selectedBase = nil
local selectedCharacter = nil
local autoUpdateConnection = nil

local function startAutoUpdate()
    if autoUpdateConnection then
        autoUpdateConnection:Disconnect()
    end
    
    autoUpdateConnection = RunService.Heartbeat:Connect(function()
        wait(2)
        updateBasesList()
        if selectedBase then
            updateCharactersList()
        end
    end)
end

local function stopAutoUpdate()
    if autoUpdateConnection then
        autoUpdateConnection:Disconnect()
        autoUpdateConnection = nil
    end
end

local function updateBasesList()
    local bases = getAllPlayerBases()
    local baseOptions = {}
    for _, baseInfo in ipairs(bases) do
        table.insert(baseOptions, baseInfo.PlayerName .. "'s Base")
    end
    BasesDropdown:Refresh(baseOptions, true)
end

local function updateCharactersList()
    if not selectedBase then
        CharsDropdown:Refresh({}, true)
        return
    end
    local characters = getCharactersFromBase(selectedBase)
    local charOptions = {}
    for _, charInfo in ipairs(characters) do
        table.insert(charOptions, charInfo.Name .. " (" .. charInfo.Folder .. ")")
    end
    CharsDropdown:Refresh(charOptions, true)
end

local function findPlayerBase()
    for baseName, base in pairs(workspace.Bases:GetChildren()) do
        local sign = base:FindFirstChild("Sign")
        if sign then
            local signPart = sign:FindFirstChild("SignPart")
            if signPart then
                local surfaceGui = signPart:FindFirstChild("SurfaceGui")
                if surfaceGui then
                    local textLabel = surfaceGui:FindFirstChild("TextLabel")
                    if textLabel and textLabel.Text then
                        if string.find(textLabel.Text, localPlayer.Name .. "'s Base") then
                            return base
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function bypassAC()
    local AC1 = localPlayer.PlayerScripts:FindFirstChild("Testing1")
    local AC2 = localPlayer.PlayerScripts:FindFirstChild("Testing2")
    
    if AC1 then
        AC1.Disabled = true
    end
    if AC2 then
        AC2.Disabled = true
    end
end

-- Custom Floating Ball (Minimize Feature)
-- Rayfield doesn't have built-in minimize to ball, so we create a custom one
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = game:GetService("CoreGui")
screenGui.Name = "MinimizeBallGui"

local floatingBall = Instance.new("ImageButton")
floatingBall.Name = "FloatingBall"
floatingBall.Size = UDim2.new(0, 52, 0, 52)
floatingBall.Position = UDim2.new(1, -70, 1, -90)
floatingBall.BackgroundColor3 = Color3.fromRGB(80, 120, 255)
floatingBall.BorderSizePixel = 0
floatingBall.Visible = false
floatingBall.ZIndex = 999
floatingBall.Parent = screenGui

local ballCorner = Instance.new("UICorner")
ballCorner.CornerRadius = UDim.new(1, 0)
ballCorner.Parent = floatingBall

local ballStroke = Instance.new("UIStroke")
ballStroke.Thickness = 2
ballStroke.Color = Color3.fromRGB(255, 255, 255)
ballStroke.Transparency = 0.6
ballStroke.Parent = floatingBall

-- Ball Drag with Edge Snapping
local ballDragging = false
local ballDragInput, ballDragStart, ballStartPos

local function updateBall(input)
    local delta = input.Position - ballDragStart
    local newPos = UDim2.new(
        ballStartPos.X.Scale, ballStartPos.X.Offset + delta.X,
        ballStartPos.Y.Scale, ballStartPos.Y.Offset + delta.Y
    )
    
    -- Simple edge snapping
    local viewport = workspace.CurrentCamera.ViewportSize
    local absPos = floatingBall.AbsolutePosition + delta
    if absPos.X < 20 then newPos = UDim2.new(0, 0, newPos.Y.Scale, newPos.Y.Offset) end
    if absPos.X > viewport.X - 72 then newPos = UDim2.new(1, -52, newPos.Y.Scale, newPos.Y.Offset) end
    if absPos.Y < 20 then newPos = UDim2.new(newPos.X.Scale, newPos.X.Offset, 0, 0) end
    if absPos.Y > viewport.Y - 72 then newPos = UDim2.new(newPos.X.Scale, newPos.X.Offset, 1, -52) end
    
    floatingBall.Position = newPos
end

floatingBall.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        ballDragging = true
        ballDragStart = input.Position
        ballStartPos = floatingBall.Position
    end
end)

floatingBall.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        ballDragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == ballDragInput and ballDragging then
        updateBall(input)
    end
end)

-- Minimize/Reopen Logic (Rayfield has a close event hook)
-- Assuming Rayfield has a way to detect close; if not, add a custom button
local CloseButton = MainTab:CreateButton({
    Name = "Close (Minimize)",
    Callback = function()
        Window:Hide() -- Hide Rayfield window
        floatingBall.Visible = true
    end
})

floatingBall.MouseButton1Click:Connect(function()
    floatingBall.Visible = false
    Window:Show() -- Show Rayfield window
end)

-- Initialize
updateBasesList()
startAutoUpdate()
bypassAC()

print("GUI Loaded with Rayfield")
